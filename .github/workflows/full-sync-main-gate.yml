name: Full Sync Main Gate

on:
  push:
    branches:
      - full-sync
  pull_request:
    branches:
      - main
    types:
      - opened
      - synchronize
      - reopened
      - ready_for_review

permissions:
  contents: write
  pull-requests: write

jobs:
  branch-policy:
    runs-on: ubuntu-latest
    steps:
      - name: Enforce full-sync -> main policy
        shell: bash
        run: |
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            if [[ "${{ github.event.pull_request.base.ref }}" != "main" || "${{ github.event.pull_request.head.ref }}" != "full-sync" ]]; then
              echo "Only full-sync -> main pull requests are allowed by policy."
              exit 1
            fi
          fi

  full-sync-main-gate:
    needs: branch-policy
    if: github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.pull_request.base.ref == 'main' && github.event.pull_request.head.ref == 'full-sync')
    runs-on: ubuntu-latest

    env:
      SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
      SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
      SUPABASE_DB_URL: ${{ secrets.SUPABASE_DB_URL }}
      SUPABASE_DB_PASSWORD: ${{ secrets.SUPABASE_DB_PASSWORD }}

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm

      - name: Set up Flutter
        uses: subosito/flutter-action@v2
        with:
          channel: stable

      - name: Set up Supabase CLI
        uses: supabase/setup-cli@v1
        with:
          version: latest

      - name: Install dependencies
        run: npm ci

      - name: Load .env placeholders
        run: cp .env.example .env

      - name: Install Playwright browser dependencies
        run: npx playwright install --with-deps chromium

      - name: Lint
        run: npm run lint

      - name: Guard Supabase environment contract
        run: npm run supabase:env:guard

      - name: Build and required test suites
        run: |
          npm run build
          npm test
          npm run test:backend
          npm run test:api
          npm run test:e2e
          npm run test:security
          npm run test:chaos
          npm run test:performance
          npm run ci:gate

      - name: Run Flutter widget tests
        working-directory: grocery_pos_mobile
        run: |
          flutter pub get
          flutter test

      - name: Apply Supabase migrations and check drift
        run: npm run supabase:ci

  auto-merge-full-sync-to-main:
    needs: full-sync-main-gate
    if: needs.full-sync-main-gate.result == 'success'
    runs-on: ubuntu-latest
    steps:
      - name: Auto-merge full-sync -> main when clean
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            async function sleep(ms) {
              return new Promise((resolve) => setTimeout(resolve, ms));
            }

            let pullNumber;

            if (context.eventName === "pull_request") {
              const pr = context.payload.pull_request;
              if (!pr || pr.base.ref !== "main" || pr.head.ref !== "full-sync") {
                core.setFailed("Policy requires full-sync -> main pull request.");
                return;
              }
              pullNumber = pr.number;
            } else {
              const { data: pulls } = await github.rest.pulls.list({
                owner,
                repo,
                state: "open",
                base: "main",
                head: `${owner}:full-sync`,
                per_page: 1
              });

              if (pulls.length === 0) {
                const created = await github.rest.pulls.create({
                  owner,
                  repo,
                  title: "[auto] full-sync -> main",
                  head: "full-sync",
                  base: "main",
                  body: "Automated promotion from full-sync after all gates passed."
                });
                pullNumber = created.data.number;
              } else {
                pullNumber = pulls[0].number;
              }
            }

            let prData;
            for (let attempt = 0; attempt < 10; attempt += 1) {
              const current = await github.rest.pulls.get({
                owner,
                repo,
                pull_number: pullNumber
              });
              prData = current.data;
              if (prData.mergeable !== null) break;
              await sleep(3000);
            }

            if (!prData) {
              core.setFailed("Unable to load pull request metadata.");
              return;
            }

            if (prData.draft) {
              core.setFailed(`PR #${pullNumber} is draft and cannot be auto-merged.`);
              return;
            }

            if (prData.mergeable !== true) {
              core.setFailed(`PR #${pullNumber} is not mergeable.`);
              return;
            }

            if (prData.mergeable_state === "dirty") {
              core.setFailed(`PR #${pullNumber} has unresolved conflicts.`);
              return;
            }

            if (["blocked"].includes(prData.mergeable_state)) {
              core.setFailed(`PR #${pullNumber} is blocked by repository protections.`);
              return;
            }

            await github.rest.pulls.merge({
              owner,
              repo,
              pull_number: pullNumber,
              merge_method: "merge"
            });

            core.info(`Merged PR #${pullNumber} from full-sync into main.`);
